# Исследование алгоритмов планирования задач на кластере с учетом топологии
Программа реализована в рамках работы над ВКР СПБГУ. (научный руководитель Корхов В.В. v.korkhov@spbu.ru)

В рамках данной программы моделируется работа кластера с определенной топологией и реализовываются различные алгоритмы размещения параллельной задачи на данном кластере.

## Используемые технологии

* С++17 - основной язык разработки
* SimGrid - фреймворк для моделирования работы клас тера
* METIS API - библиотека для разбаения графа на части

## Рассматриваемые топологии

### Моделируемые топологии кластера

Детальное описание кластеров находится в файле platform.xml. Мы рассматриваем следующие топологии:

* 3d torus
* 2d torus
* 6,4-fatTree
* 6,4:2-thTree

### Топологии задачи

Под топологией задачи мы понимаем взвешенный граф, который отображает схему коммуникаций подзадач. Рассматриваем следующие топологии:

* Звезда
* Плоская решетка
* Куб
* Двоичное дерево

## Алгоритмы размещения

### Простое и рандомное размещение

В простом размещении подзадачи размещаются на свободных узлах кластера согласно нумерации узлов кластера.

В рандомном размещении свободные вычислительные узлы выбираются произвольным образом.

### Оптимальное размещение в сетчатых топологиях

Для топологий тора строится одномерная кривая Гилберта, которая весьма плотно заполняетс пространство. После чего выбирается интервал, 
в который входит достаточное свободных вычислительных узлов, таким образом, чтобы расстояние между первым и последним элементом было минимально.

### Оптимальное размещение в иерархических топологиях

Для топологий толстого и тонкого дерева мы ищем коммутатор на самом низком уровне, который имеет достаточное количество вычислительных узлов. 
После мы рекурсивно сортируем дочерние коммутаторы по невозрастанию вычислительных узлов и выбираем подходящие вычислительные узлы.

### Продвинутое размещение

Размещение с учетом топологии задачи проходит в 3 этапа:

1. Выбор узлов - берутся результаты оптимального размещения
2. Построение дерева ближайших соседей - вычислительные узлы находятся на листьях деревьев, не листьевые элементы отображают группу смежных узлов
3. Отображение задачи

Для отображения задачи на дерево ближайших соседей используется алгоритм, в котором мы разбиваем топологию на k частей, где k - количество детей у дерева ближайших соседей, 
таким образом, чтобы размер каждой части топологии задачи равнялся соответствующеему поддереву и объем передаваемых сообщений между различными частями задачи был минимален.

После этого мы рекурсивно запускаем данный алгоритм для соответствующего поддерева и части задачи до тех пор, пока не дойдем до листьев дерева ближайших соседей (вычислительных узлов)

## Описание входных данных

Данные читаются из json файла. Путь к файлу передается в качестве аргумента командной строки. Данный файл имеет следующую структуру:
```
[
  {
    "topologyType": 0,
    "jobs": [
      {
        "jobType": 0,
        "placementMode": 0,
        "processes": 4096,
        "isValid": true,
        "countP2pMessage": 50,
        "cost": 1048576,
        "path": "output.txt"
      }
    ]
  }
]
```

## Визуализация результатов

Результаты экспериментов на пустом кластере:

![exp1.png](resultImage%2Fexp1.png)



Результаты эксперементов на частично заполненном кластере:

![exp2.png](resultImage%2Fexp2.png)